var DocumentManager = function () { "use strict"; const e = "font_preload_bed", t = "rasterize"; function i(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || !e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t || "default"); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == typeof t ? t : t + "" }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } const s = { encode: window.btoa.bind(window), decode: window.atob.bind(window) }; function n(e, t) { e.href = t } const a = function () { const e = navigator.userAgent.toLowerCase(); return e.indexOf("mobile") > -1 && e.indexOf("safari/") > -1 && -1 === e.indexOf("chrome/") }(); class r { constructor(e) { this.possibleEvents = e || [], this.initEventHelper() } initEventHelper() { this.eventListenerEnabled = !0, this.eventListeners = {}; for (let e = 0; e < this.possibleEvents.length; e++)this.eventListeners[this.possibleEvents[e]] = {} } addEvent(e, t) { if (!this.eventListeners[e]) throw Error(e + " is not a valid type of event"); this.eventListeners[e].next_uid || (this.eventListeners[e].next_uid = 1), t._event_listener_uid || (t._event_listener_uid = this.eventListeners[e].next_uid, this.eventListeners[e].next_uid++), this.eventListeners[e][t._event_listener_uid] = t } removeEvent(e, t) { if (!this.eventListeners[e]) throw Error(e + " is not a valid type of event"); delete this.eventListeners[e][t._event_listener_uid] } fireEvent(e, ...t) { if (!this.eventListenerEnabled) return; const i = this.eventListeners[e], s = e => { e.apply(this, t) }; for (const n in i) "next_uid" !== n && Object.prototype.hasOwnProperty.call(i, n) && s(i[n]) } } class o { constructor() { } name() { return this._name } register(e, t) { if (this.registered) throw Error("This ViewManager is already registered"); this.registered = !0, this.documentManager = e, this.viewportManager = t, this._currentPageWidth = window.defaultViewWidth, this._currentZoomMultiplier = 1, this._updatePageWidths(); const i = this.documentManager.firstVisiblePage; this._register(e, t), i && this.documentManager.gotoPage(i.pageNum, {}), e.executeCallbacks() } _zoomedPageWidth() { return this._currentPageWidth * this._currentZoomMultiplier } _updatePageWidths() { this.documentManager.setPageWidths(this._zoomedPageWidth()) } isTopPageInView() { return !0 } _register(e, t) { } unregister() { if (!this.registered) throw Error("This ViewManager is already unregistered"); this.isFullscreen && this.exitFullscreen(), this._setBodyWidth(), this._unregister(), this.registered = !1, delete this.documentManager, delete this.viewportManager } _unregister() { } _pagingStep() { return 1 } gotoPage(e, t) { if (!this.registered) throw Error("ViewManager must be registerd to call gotoPage"); this._gotoPage(e, t) } _gotoPage(e, t) { } _fireHideExtras() { this.documentManager._fireHideExtras(), this._extrasHidden = !0 } _fireShowExtras() { this.documentManager._fireShowExtras(), this._extrasHidden = !1 } enterFullscreen() { if (this.isFullscreen) throw Error("Fullscreen is already set"); this._setBodyWidth(), this.viewportManager.addEvent("resize", this._fullscreenResizedCallback), this._fireHideExtras(), this.resetZoom(), this._enterFullscreen(), this._fullscreenResized(this.viewportManager.viewRect), this._currentPageWidth = this.viewportManager.viewRect.width, this.isFullscreen = !0; const e = this.documentManager.firstVisiblePage; e && this.documentManager.gotoPage(e.pageNum, {}), this.documentManager._fireEnteredFullscreen() } exitFullscreen() { if (!this.isFullscreen) throw Error("Fullscreen is not set"); this.viewportManager.removeEvent("resize", this._fullscreenResizedCallback), this._fireShowExtras(), this.resetZoom(), this._exitFullscreen(), this.isFullscreen = !1; const e = this.documentManager.firstVisiblePage; e && this.documentManager.gotoPage(e.pageNum, {}), this.documentManager._fireExitedFullscreen() } _viewBarWidth() { return this._extrasHidden ? 0 : this.documentManager.options.extrasWidth } _enterFullscreen() { } _exitFullscreen() { } _fullscreenResized(e) { } _scrollWithZoom(e, t) { window.scrollTo(0, e.top * t) } zoom(e) { const t = this.viewportManager.viewRect; t && (this._currentZoomMultiplier *= e, this._setBodyWidth(), this._updatePageWidths(), this.documentManager.setIsScrolling(!0), this._scrollWithZoom(t, e), this._zoomed(), this.documentManager.setIsScrolling(!1), this.documentManager._fireZoomed(e)) } _zoomed() { } resetZoom() { this._currentZoomMultiplier = 1, this._setBodyWidth(), this._updatePageWidths(), this._zoomed() } _setBodyWidth() { if (window.DocumentManager.scrollParent) return; if (!1 === window.DocumentManager.updateBodyWidth) return; const e = document.documentElement.clientWidth, t = this._zoomedPageWidth() + this._viewBarWidth() + 10, i = document.getElementById("global_header"); t > e ? (document.body.style.width = `${t}px`, i && (i.style.width = `${e}px`)) : (document.body.style.width = "100%", i && (i.style.width = "100%")) } } class h extends o { constructor() { super(), this._name = "scroll", this._verticalPositionChangeCallback = () => { this.checkAndUpdateVisiblePages() }, this._fullscreenResizedCallback = () => { this._fullscreenResized() }, this.shouldRestorePosition = !0 } _updateInViewport(e) { const t = this.viewportManager.viewRect, i = e.boundingRect, s = e.isVisible; return e.isVisible = !(!t || !i) && (i.left < t.right && i.right > t.left && i.top < t.bottom && i.bottom > t.top), e.visibleHeight = e.isVisible ? Math.min(i.bottom, t.bottom) - Math.max(i.top, t.top) : 0, this.adjacentVisiblePages = 1, s !== e.isVisible } checkAndUpdateVisiblePages() { let e = !1; for (const t in this.pages) if (Object.prototype.hasOwnProperty.call(this.pages, t)) { const i = this.pages[t], s = this._updateInViewport(i); e = e || s } e ? this.documentManager.visiblePagesChanged() : this.documentManager.scheduleLogPageView(), this._updateDisplayOnPages(), this.documentManager.updateMostVisiblePage() } _updateDisplayOnPages() { if (this.documentManager.firstVisiblePage && this.documentManager.lastVisiblePage) { const e = this.documentManager.firstVisiblePage.pageNum - this.adjacentVisiblePages, t = this.documentManager.lastVisiblePage.pageNum + this.adjacentVisiblePages; for (const i in this.pages) if (Object.prototype.hasOwnProperty.call(this.pages, i)) { const s = this.pages[i]; s && (s.pageNum >= e && s.pageNum <= t ? s.display() : (s.hide(), this.documentManager.fireEvent("pageHide", s))) } } } _zoomed() { this.checkAndUpdateVisiblePages() } _register(e) { this.pages = e.pages, this.viewportManager.addEvent("vertical", this._verticalPositionChangeCallback); for (const t in this.pages) if (Object.prototype.hasOwnProperty.call(this.pages, t)) { this.documentManager.pages[t].containerElem.style.display = "" } this.documentManager.setPageMissingModulesVisible(!0), this.documentManager._updatePageBoundingRects(), this.checkAndUpdateVisiblePages() } isTopPageInView() { const e = this.documentManager.firstVisiblePage; return !e || (this.documentManager._expectedFirstPageNum > e.pageNum || e.boundingRect.top + 5 >= this.viewportManager.viewRect.top) } _unregister() { this.viewportManager.removeEvent("vertical", this._verticalPositionChangeCallback), delete this.pages } _gotoPage(e, t) { if (t = t || {}, !Object.prototype.hasOwnProperty.call(this.pages, e)) return; const i = this.documentManager.pages[e]; this.documentManager.setIsScrolling(!0); const s = this.documentManager.viewportManager.container; return i._updateBoundingRect(), s === window ? scrollTo(i.boundingRect.left, i.boundingRect.top - (t.offset || 0)) : s.scrollTop = i.boundingRect.top - (t.offset || 0), this.documentManager.setIsScrolling(!1), this.documentManager.isScrolling || this.documentManager.visiblePagesChanged(), i.pageNum } _gotoNextPage() { this.documentManager.firstVisiblePage && this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum + 1, { direction: 1 }) } _gotoPreviousPage() { this.documentManager.firstVisiblePage && this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum - 1, { direction: -1 }) } _setWidth(e) { const t = this.pagePosition(); this._currentPageWidth = e, this._updatePageWidths(), this._setBodyWidth(), this.restorePosition(t) } _fullscreenResized() { this._setWidth((window.innerWidth || document.documentElement.clientWidth) - 30) } _enterFullscreen() { this._previousPageWidth = this._currentWidth || window.defaultViewWidth } _exitFullscreen() { this._setWidth(this._previousPageWidth) } pagePosition() { const e = this.viewportManager.container, t = this.documentManager.pages[this.documentManager.currentPageNum() || 1], i = e.scrollTop, s = e.scrollLeft, n = (i - t.boundingRect.top) / t.boundingRect.height, a = (s - t.boundingRect.left) / t.boundingRect.width; return [t.pageNum, n, a] } restorePosition(e) { if (this._disableRestorePosition) return; const t = this.pages[e[0]].containerElem; if (this._gotoPage(e[0], { offset: -Math.floor(e[1] * t.clientHeight) }), null !== e[2]) { const i = this.viewportManager.container; let s = e[2]; s = Math.floor(s * t.clientWidth); const n = t.clientWidth - i.clientWidth; i.scrollLeft = Math.min(n, s) } } zoom(e) { if (!this.viewportManager.viewRect) return; const t = this.pagePosition(); this._currentZoomMultiplier *= e, this._setBodyWidth(), this._updatePageWidths(), this.shouldRestorePosition && this.restorePosition(t), this._zoomed(), this.documentManager._fireZoomed(e) } } class l extends o { constructor() { super(), this._name = "slideshow", this.currentPageId = null, this._fullscreenResizedCallback = e => { this._fullscreenResized(e) } } _register() { this._prepareDisplay(); const e = document.getElementById("scroll_preventer"); e && (e.style.overflow = "hidden", e.style.height = "100%") } _unregister() { const e = document.getElementById("scroll_preventer"); e && (e.style.overflow = "visible", e.style.height = "auto") } _prepareDisplay() { for (const e in this.documentManager.pages) if (Object.prototype.hasOwnProperty.call(this.documentManager.pages, e)) { const t = this.documentManager.pages[e]; t.containerElem.style.display = "none", t.hide() } this.documentManager.setPageMissingModulesVisible(!1), this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1) } _setPageBounds(e) { const t = this.documentManager.pages[this.currentPageId]; t && t.setBounds(e.width, e.height) } _gotoPage(e) { if (!Object.prototype.hasOwnProperty.call(this.documentManager.pages, e)) return; let t; this.currentPageId && (t = this.documentManager.pages[this.currentPageId], t && (t.isVisible = !1, t.containerElem.style.display = "none", t.hide())), this.currentPageId = e, t = this.documentManager.pages[e], this.isFullscreen && this._setPageBounds(this.viewportManager.viewRect), t.isVisible = !0, t.display(!0), t.containerElem.style.display = "", t._updateBoundingRect(), this.documentManager.visiblePagesChanged() } _setWidth(e) { this._currentPageWidth = e, this.documentManager.setPageWidths(e) } _fullscreenResized(e) { this._setPageBounds(e) } _enterFullscreen() { this._previousPageWidth = this._currentPageWidth || window.defaultViewWidth } _exitFullscreen() { this._setWidth(window.defaultViewWidth), this._setBodyWidth() } } class g { constructor(e = {}) { const { url: t, id: i, shortstyle: s, family: n, fallback: a, weight: r, style: o } = e; this.url = t, this.id = i, this.shortstyle = s, this.family = n, this.fallback = a, this.weight = r, this.style = o } setupFont() { const { url: e, family: t, weight: i, style: s } = this, n = new FontFace(t, `url(${e})`, { weight: i, style: s }); return n.display = "swap", n } getFontFamily() { return `font-family: ${this.family};` } getFontWeight() { return `font-weight: ${this.weight};` } getFontStyle() { return `font-style: ${this.style};` } createPreloadElem() { return `<span style="font-family: ${this.family}">scribd.</span>` } } class d { constructor(e) { this.fonts = [], this.docManager = e, this._cssRuleQueue = [], this._fontLoadQueue = [] } addCSSRuleToQueue(e, t = !1) { this._cssRuleQueue.push(e), t && this._flushCSSRuleQueue() } addFont(e, t, i, s, n, a) { const r = this._fontUrl(i, e), o = new g({ url: r, id: e, shortstyle: t, family: i, fallback: s, weight: n, style: a }); return this.fonts[e] = o, o } addFontToQueue(e) { const t = this.fonts[e]; t._loadQueued || (t._loadQueued = !0, this._fontLoadQueue.push(t)) } flushFontQueue() { if (0 === this._fontLoadQueue.length) return; if (this.docManager.displayType === t) return; const e = this._fontLoadQueue; return this._fontLoadQueue = [], new Promise(requestAnimationFrame).then(() => this._loadFonts(e)) } initStyles() { this.docManager.displayType !== t && (this._initFamilyCSS(), this._initHidersCSS(), this._flushCSSRuleQueue("preload_styler")) } setupTestElements() { } maxFontsLoading() { return 10 } _appendNewStyleBlock() { const e = document.createElement("style"); return document.getElementsByTagName("head")[0].appendChild(e), e } _flushCSSRuleQueue(e) { if (this._cssRuleQueue.length > 0) { const t = e && document.getElementById(e) || this._appendNewStyleBlock(), i = this._cssRuleQueue.join("\n"); t.appendChild(document.createTextNode(i)), this._cssRuleQueue = [] } } _loadFonts(e, t = 0, i = 10) { const s = [], n = [], a = Math.min(t + i, e.length); for (let r = t; r < a; r++) { const t = e[r].setupFont(), i = new Promise(e => { t.load().then(t => { e(t) }).catch(t => { e(t) }) }); s.push(i), n.push(`.${t.family}`) } return Promise.all(s).then(s => { if (s.forEach(e => { e instanceof FontFace && document.fonts.add(e) }), this.addCSSRuleToQueue(`${n.join(", ")} { display: unset; }`, !0), a < e.length) return new Promise(requestAnimationFrame).then(() => this._loadFonts(e, t + i, i)) }) } _fontUrl(e, t) { const i = [this.docManager.fontAggregatorHosts[this.docManager._currentFontAggregatorHostIdx], this.docManager.assetPrefix, "fonts"]; return i.push(`${t.toString().padStart(4, 0)}.woff2`), i.join("/") } _initHidersCSS() { const e = []; for (let t = 0; t < this.fonts.length; t++)e.push(`.${this.fonts[t].family}`); this.addCSSRuleToQueue(`${e.join(", ")} { display: none; }\n`) } _hasEmbedDiv() { return "undefined" !== typeof scribd && "undefined" !== typeof scribd.embed_div_id } _getEmbedDivSelector() { return `#${scribd.embed_div_id} ${selector}` } _initFamilyCSS() { for (let e = 0; e < this.fonts.length; e++) { const t = this.fonts[e].family, i = this.fonts[e].fallback, s = this.fonts[e].weight, n = this.fonts[e].style; let a = `div.${t} span`; this._hasEmbedDiv() && (a = this._getEmbedDivSelector()), this.addCSSRuleToQueue(`${a} { font-family: ${t}, ${i}; font-weight: ${s}; font-style: ${n};\n}`) } } } class u extends d { constructor(e) { super(e) } getFontAggregatorHostUrl(e) { const t = [this.docManager.fontAggregatorHosts[this.docManager._currentFontAggregatorHostIdx], this.docManager.assetPrefix, e.join(","), 12]; return t.push("ttfs.css"), t.join("/") } getFontAggregatorHostForFonts(e) { const t = []; for (let i = 0; i < e.length; i++)t.push(e[i].shortstyle + e[i].id); return t.sort(), this.getFontAggregatorHostUrl(t) } _addCSSLink(e) { const t = document.createElement("link"); t.href = e, t.rel = "stylesheet", t.type = "text/css"; document.getElementsByTagName("head")[0].appendChild(t) } flushFontQueue() { if (0 === this._fontLoadQueue.length) return; if (this.docManager.displayType === t) return; const e = this._fontLoadQueue; this._fontLoadQueue = []; const i = this.getFontAggregatorHostForFonts(e); this._addCSSLink(i), this._flushCSSRuleQueue() } setupTestElements() { if (this.docManager.displayType === t) return; let i = ""; for (let e = 0; e < this.fonts.length; e++) { i += this.fonts[e].createPreloadElem() } const s = document.getElementById(e); s.innerHTML = i, document.body.appendChild(s), this.addCSSRuleToQueue(`#${e} span {display: block; visibility: hidden}`, true) } maxFontsLoading(e, t, i) { return e >= 20 && 0 === t && i >= 11 || e >= 20 && i >= 100 ? 10 : 100 } } class c extends r { constructor() { super(c.EVENT_NAMES), this.viewRect = null, this.enabled = !1, this._scrollCallback = () => { this._eventHandler("scroll") }, this._resizeCallback = () => { this._eventHandler("resize") } } _makeViewRect() { const e = this.container, t = document.documentElement, i = e.scrollTop || e.scrollY || e.pageYOffset || t.scrollTop, s = e.scrollLeft || e.scrollX || e.pageXOffset || t.scrollLeft, n = e.clientWidth || e.innerWidth || t.clientWidth, a = e.clientHeight || e.innerHeight || t.clientHeight, r = { top: i, left: s, right: s + n, bottom: i + a, width: n, height: a }; if (this.container !== window) { const e = this.container.getBoundingClientRect && this.container.getBoundingClientRect(); e && (r.offsetX = e.left, r.offsetY = e.top) } return r } _updateViewRect() { const e = this.viewRect; this.viewRect = this._makeViewRect(); return { xChanged: !e || e.left !== this.viewRect.left || e.width !== this.viewRect.width, yChanged: !e || e.top !== this.viewRect.top || e.height !== this.viewRect.height } } _eventHandler(e) { const t = this._updateViewRect();["resize", "both"].includes(e) && (t.xChanged || t.yChanged) && this.fireEvent("resize", this.viewRect), (t.xChanged || t.yChanged) && this.fireEvent("either", this.viewRect), t.xChanged && this.fireEvent("horizontal", this.viewRect), t.yChanged && this.fireEvent("vertical", this.viewRect) } enable() { if (this.enabled) throw Error("ViewportManager has already been enabled"); this.enabled = !0, this.container = window.DocumentManager.scrollParent || window, this._eventHandler("both"), this.container.addEventListener("resize", this._resizeCallback, !1); (window.DocumentManager.scrollParent ? this.container : window.document).addEventListener("scroll", this._scrollCallback, !1) } disable() { if (!this.enabled) throw Error("ViewportManager has already been disabled"); this.enabled = !1, window.removeEventListener("resize", this._resizeCallback, !1), this.container.removeEventListener("scroll", this._scrollCallback, !1) } } i(c, "EVENT_NAMES", ["vertical", "horizontal", "either", "resize"]); class m { constructor(e, t) { this.pages = [], this.loaded = !1, this.fonts = {}, this.numFonts = 0, this.fontLoader = t, this.groupNum = e || 0 } addPage(e) { for (let t = 0; t < e.fonts.length; t++) { const i = e.fonts[t]; void 0 === this.fonts[i] && (this.fonts[i] = !0, this.numFonts += 1) } this.pages.push(e) } isFull() { const e = this.pages.length, t = this.groupNum, i = this.numFonts; return this.hasLoaded || i > this.fontLoader.maxFontsLoading(i, t, e) } load(e) { if (this.hasLoaded) return; this.hasLoaded = !0; const t = () => { for (const e in this.fonts) Object.prototype.hasOwnProperty.call(this.fonts, e) && this.fontLoader.addFontToQueue(e); this.fontLoader.flushFontQueue() }; e ? window.setTimeout(t.bind(this), e) : t.call(this) } newNextGroup() { return new m(this.groupNum + 1, this.fontLoader) } } class p { constructor(e) { for (const i in p._defaultParams) Object.prototype.hasOwnProperty.call(p._defaultParams, i) && (this[i] = e[i] || p._defaultParams[i]); const t = this._getMissingRequiredParams(); if (t.length) throw Error("Missing required Page param(s): " + t.join(", ")); if (!this.contentUrl && !this.innerPageElem) throw Error("Must initialize a page with either a contentUrl or innerPageElem element"); if (!0 === this.containerElem.boundToPageObj) throw Error("Container Elem is already bound to a page.  We shouldn't get here"); this.containerElem.boundToPageObj = !0, this._targetHeight = null, this._targetWidth = null, this._innerPageVisible = !!this.innerPageElem, this._imagesTurnedOn = !1, this.boundingRect = null, this.isVisible = !1, this.displayDirty = !0, this.displayOn = null, this.loadHasStarted = !!this.innerPageElem } _getMissingRequiredParams() { const e = []; let t; for (let i = 0; i < p._requiredParams.length; i++)t = p._requiredParams[i], this[t] || e.push(t); return e } _updateBoundingRect() { let e, t, i, s; if (this.containerElem.getBoundingClientRect && this.docManager.viewportManager.viewRect) { const n = this.containerElem.getBoundingClientRect(), a = this.docManager.viewportManager.viewRect; t = n.left + a.left, e = n.top + a.top, a.offsetX && (t -= a.offsetX), a.offsetY && (e -= a.offsetY), i = n.right - n.left, s = n.bottom - n.top, this.boundingRect = { left: t, top: e, bottom: e + s, right: t + i, width: i, height: s } } else e = this.containerElem.offsetTop, t = this.containerElem.offsetLeft, i = this.containerElem.offsetWidth, s = this.containerElem.offsetHeight, this.boundingRect = { left: t, top: e, bottom: e + s, right: t + i, width: i, height: s } } _setContainerContents(e) { const t = e.replace(/<noscript *><img[^<>]*\/><\/noscript *>/g, ""), i = document.createElement("div"); i.innerHTML = t.trim(); const s = i.firstChild; this.containerElem.appendChild(s), this.innerPageElem = s, this.turnOnLinks(), this.fixSVGFonts(), this._fitContentsToWidth(), this.displayDirty = !0, this.displayOn ? this.display() : this.hide() } fixSVGFonts() { if (!this._svgFontsFixed && this.innerPageElem) { if (a) { const e = function (t) { if (t.nodeType === document.TEXT_NODE) { const i = t.textContent.search(/[  \n][^ \n ]/); i >= 0 && e(t.splitText(i + 1)) } else { const i = t.childNodes; for (let t = 0; t < i.length; t++)e(i[t]) } }, t = function (e) { const i = e.childNodes; for (let s = 0; s < i.length; s++) { const n = i[s]; if (n.nodeType === document.ELEMENT_NODE) t(n); else { const t = i[s + 1]; t && "#text" === t.nodeName && e.insertBefore(document.createElement("span"), t) } } }; e(this.innerPageElem), t(this.innerPageElem) } this._svgFontsFixed = !0 } } imagePageContent(e) { return `<img src="${e}"></img>` } load() { if (this.currentlyLoading = !0, this.loadHasStarted = !0, this.innerPageElem) throw Error("We already have loaded this page, but it looks like you called loadPage again"); this.loadFonts(); const e = `page${this.pageNum}_callback`; if (window[e]) try { delete window[e] } catch { window[e] = void 0 } if (this.docManager.displayType === t) return delete this.currentlyLoading, void this._setContainerContents(this.imagePageContent(this.contentUrl)); const i = document.createElement("script"); window[e] = t => { i && i.parentNode === document.body && document.body.removeChild(i); const s = t[0]; delete this.currentlyLoading, this._setContainerContents(s); const n = document.getElementById(this.containerElem.id); if (this.docManager.fireEvent("pageLoaded", this.containerElem), n && this.docManager.lazyImageObserver) { const e = n.querySelectorAll(".absimg"); for (let t = 0; t < e.length; t++)e[t].style.display = "block"; this.docManager.observeImages(this.containerElem) } try { delete window[e] } catch { window[e] = void 0 } }, i.src = this.contentUrl, i.type = "text/javascript", i.charset = "UTF-8", window.Osano && (i.dataset.osano = "ESSENTIAL"), document.body.appendChild(i) } remove() { if (this.innerPageElem) { this.innerPageElem.parentNode.removeChild(this.innerPageElem), delete this.innerPageElem, delete this.currentLoading, delete this.loadHasStarted, this._linksTurnedOn = !1, this._imagesTurnedOn = !1, this._svgFontsFixed = !1 } } display(e, t) { if ((!this.displayOn || this.displayDirty) && (this.displayOn = !0, !this.currentlyLoading)) { if (!this.innerPageElem) return this.loadHasStarted ? void 0 : e ? void this.load() : void 0; this.displayDirty = !1, t || (this._linksTurnedOn || this.turnOnLinks(), this._imagesTurnedOn || this.docManager.lazyImageObserver || this.turnOnImages(), this._svgFontsFixed || this.fixSVGFonts()), this.loadFonts(), this._innerPageVisible || (this.containerElem.className = this.containerElem.className.replace(/placeholder|not_visible/g, ""), this._innerPageVisible = !0, t || (this.innerPageElem.style.display = "block")) } } hide() { (this.displayOn || this.displayDirty) && (this.displayOn = !1, this.innerPageElem && (this.displayDirty = !1, this.containerElem.className = this.containerElem.className + " not_visible", this._innerPageVisible = !1)) } setLoadFontGroup(e) { e.addPage(this), this.loadFontGroup = e } loadFonts() { this.loadFontGroup.load() } _setZoomScale(e) { const t = this.innerPageElem, i = `scale(${e})`; t.style.transform !== i && (t.style.transform = i, t.style.transformOrigin = "top left") } _fitContentsToWidth() { if (this._targetWidth && this.innerPageElem) { const e = this._targetWidth / this.origWidth; this._setZoomScale(e) } } setWidth(e) { const t = Math.ceil(e / this.origWidth * this.origHeight); this._targetWidth !== e && (this.containerElem.style.width = e + "px", this._targetWidth = e), this._targetHeight !== t && (this.containerElem.style.height = t + "px", this._targetHeight = t), this._fitContentsToWidth() } setBounds(e, t) { this.origWidth / this.origHeight > e / t ? t = Math.ceil(e / this.origWidth * this.origHeight) : e = Math.ceil(t / this.origHeight * this.origWidth), this._targetWidth !== e && (this.containerElem.style.width = e + "px", this._targetWidth = e), this._targetHeight !== t && (this.containerElem.style.height = t + "px", this._targetHeight = t), this._fitContentsToWidth() } turnOnImages() { if (!this.innerPageElem) throw Error("Can't turn on images for a page that's not loaded"); if (this._imagesTurnedOn) throw Error("Images have already been turned on for this document"); this._imagesTurnedOn = !0; const e = this.innerPageElem.getElementsByTagName("img"); for (let t = 0; t < e.length; t++)this.docManager.lazyLoad(e[t]) } turnOnLinks() { if (!this.innerPageElem) throw Error("Can't turn on links for a page that's not loaded"); if (this._linksTurnedOn) throw Error("Links have already been turned on for this document"); this._linksTurnedOn = !0; const e = this.docManager, t = function (t) { return function () { e.gotoPage(t.substring(4)) } }, i = this.innerPageElem.getElementsByTagName("a"); for (let a = 0; a < i.length; a++) { const e = i[a]; if (e.className.toLowerCase().search("ll") > -1 && !e.href) { const i = e.getAttribute("orig"); if (i) { let a = s.decode(i).replace(/^j[\W]*a[\W]*v[\W]*a[\W]*s[\W]*c[\W]*r[\W]*i[\W]*p[\W]*t[\W]*:|^f[\W]*i[\W]*l[\W]*e[\W]*:/gi, ""); a.search(/^page/) > -1 ? e.onclick = t(a) : (a.search(/^(http|ftp)/) < 0 && (a = "http://" + a), e.target = "_blank", n(e, a), e.rel = "nofollow Scribd") } } } } } i(p, "_defaultParams", { containerElem: null, innerPageElem: null, contentUrl: null, origWidth: null, origHeight: null, fonts: null, docManager: null, pageNum: null }), i(p, "_requiredParams", ["origWidth", "origHeight", "fonts", "docManager", "containerElem", "pageNum"]); const f = ["dragstart, selectstart, contextmenu"], _ = function (e) { e.preventDefault() }; class P extends r { constructor(e, t, i) { super(P.EVENT_NAMES), this.options = i || {}, this.options.extrasWidth = this.options.extrasWidth || window.extrasWidth, this.defaultViewMode = e || "scroll", this.mobile = t || !1, this.callbacks_ready = !1, this.callbacks = [], this.pages = {}, this._pageWidths = null, this.options.hasWoffFonts ? (this._fontLoader = new d(this), this.adjacentFontLoadPages = 1) : (this._fontLoader = new u(this), this.adjacentFontLoadPages = 8), this.viewManagers = { scroll: new h, slideshow: new l }, this.viewportManager = new c, this._currentFontAggregatorHostIdx = 0, this.visiblePages = [], this.firstVisiblePage = null, this.lastVisiblePage = null, this.firstHiddenPageNum = null, this.truncateDocument = window.__truncate_document || !1, this.currentFontGroup = new m(0, this._fontLoader), this.isScrolling = !1, this._scrollingCount = 0, "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype && "isIntersecting" in window.IntersectionObserverEntry.prototype && this.setupLazyImageObserver() } setupLazyImageObserver() { this.lazyImageObserver = new IntersectionObserver(e => { e.forEach(e => { e.isIntersecting && this.lazyLoad(e.target) }) }) } lazyLoad(e) { e.className.toLowerCase().search("absimg") > -1 && !e.src && (e.src = this.subImageSrc(e.getAttribute("orig")), e.removeAttribute("orig"), e.style.display = "block", this.lazyImageObserver && this.lazyImageObserver.unobserve(e)) } observeImages(e) { if (!this.lazyImageObserver || !this.lazyImageObserver.observe) return; const t = e.getElementsByTagName("img"); for (let i = 0; i < t.length; i++)t[i].className.toLowerCase().search("absimg") > -1 && this.lazyImageObserver.observe(t[i]) } loadImages(e) { const t = e.getElementsByTagName("img"); for (let i = 0; i < t.length; i++)this.lazyLoad(t[i]) } registerCallback(e) { this.callbacks_ready ? e.call(this) : this.callbacks.push(e) } executeCallbacks() { this.callbacks_ready = !0, this.callbacks.forEach(e => { e.call(this) }) } disableRestorePosition() { this.viewManagers.scroll._disableRestorePosition = !0 } _fireZoomed(e) { this.fireEvent("zoomed", e) } nextFontAggregatorHost() { return this._currentFontAggregatorHostIdx = (this._currentFontAggregatorHostIdx + 1) % this.fontAggregatorHosts.length, this.fontAggregatorHosts[this._currentFontAggregatorHostIdx] } _fireHideExtras() { this.fireEvent("hideExtras") } _fireShowExtras() { this.fireEvent("showExtras") } currentPageNum() { return this._expectedFirstPageNum } setupTestElements() { this._fontLoader.setupTestElements() } pageCount() { if (Object.prototype.hasOwnProperty.call(this, "_pageCount")) return this._pageCount; let e = 0; for (const t in this.pages) Object.prototype.hasOwnProperty.call(this.pages, t) && e++; return this._pageCount = e, this._pageCount } truncatedPagesString() { return `${this.firstHiddenPageNum}-${this.originalPageCount}` } setupPaidDocument(e, t) { this.allowedPages = e, this.originalPageCount = t, this._allowedPagesHash = [], this._maximumAllowedPage = Math.max.apply(null, this.allowedPages), this._minimumAllowedPage = Math.min.apply(null, this.allowedPages), this._isPaidDocument = !0, this._pageMissingElements = []; for (let i = 0; i < e.length; i++)this._allowedPagesHash[e[i]] = !0, (i > 0 && e[i] > e[i - 1] + 1 || 0 === i && 1 !== e[i]) && this._pageMissingElements.push("page_missing_explanation_" + e[i].toString()); this._maximumAllowedPage !== this.originalPageCount && this._pageMissingElements.push("page_missing_explanation_" + (this.originalPageCount + 1).toString()) } minimumPageNumber() { return "book" === this.viewMode() ? 0 : 1 } maximumPageNumber() { return this.allowedPages ? this.originalPageCount : this.pageCount() } getClosestPageNumber(e, t) { if (!this.allowedPages) return e; if (this._allowedPagesHash[e]) return e; if (e >= this._maximumAllowedPage) return this._maximumAllowedPage; if (e <= this._minimumAllowedPage) return this._minimumAllowedPage; for (let i = 1; i <= this.originalPageCount; i++) { if (t <= 0 && !0 === this._allowedPagesHash[e - i]) return e - i; if (t >= 0 && e + i < this.originalPageCount && !0 === this._allowedPagesHash[e + i]) return e + i } } setPageMissingModulesVisible(e) { if (this._isPaidDocument) for (let t = 0; t < this._pageMissingElements.length; t++) { const i = document.getElementById(this._pageMissingElements[t]); i && (this.truncateDocument ? i.remove() : i.style.display = e ? "block" : "none") } } getNextAvailablePage(e) { return this.getClosestPageNumber(e, 1) } getPreviousAvailablePage(e) { return this.getClosestPageNumber(e, -1) } flushFontQueue() { this._fontLoader.flushFontQueue() } getMostVisiblePageNum() { let e = null; for (const t of this.visiblePages) (!e || t.visibleHeight > e.visibleHeight) && (e = t); return e?.pageNum } updateMostVisiblePage() { const e = this.getMostVisiblePageNum(); e !== this._mostVisiblePageNum && (this._mostVisiblePageNum = e, this.fireEvent("mostVisiblePageChanged", this._mostVisiblePageNum)) } visiblePagesChanged() { const e = []; for (const i in this.pages) if (Object.prototype.hasOwnProperty.call(this.pages, i)) { const t = this.pages[i]; t.isVisible && e.push(t) } if (!e.length) return; e.sort(function (e, t) { return e.pageNum < t.pageNum ? -1 : 1 }), this.fireEvent("visiblePagesChanged", e), this.visiblePages = e; const t = this.firstVisiblePage; this.firstVisiblePage = e.length > 0 ? e[0] : null, this.lastVisiblePage = e.length > 0 ? e[e.length - 1] : null, this.isScrolling || (this._loadAdjacentFonts(), this._loadAdjacentPages()), (this.firstVisiblePage === t || this.firstVisiblePage && t) && this.firstVisiblePage.pageNum === t.pageNum || !this.isScrolling && this.firstVisiblePage && this._updateExpectedFirstPage(this.firstVisiblePage.pageNum), this.scheduleLogPageView() } constrain(e, t, i) { return Math.min(i, Math.max(t, e)) } boundingRatioForPage(e) { const t = this.viewportManager.viewRect, i = e.boundingRect, s = i.bottom - i.top, n = i.right - i.left; return { left: (t.left - i.left) / n, right: (t.right - i.right) / n + 1, top: this.constrain((t.top - i.top) / s + e.pageNum, e.pageNum, e.pageNum + 1), bottom: this.constrain((t.bottom - i.bottom) / s + e.pageNum + 1, e.pageNum, e.pageNum + 1) } } scheduleLogPageView() { this.logPageViewTimout && window.clearTimeout(this.logPageViewTimout), this.logPageViewTimout = window.setTimeout(() => { this.logPageView(), this.logPageViewTimout = null }, 1e3) } _floor2(e) { return Math.floor(100 * e) / 100 } getVisibleBBox() { const e = {}; if (this.firstVisiblePage) { const t = this.boundingRatioForPage(this.firstVisiblePage); e.left = t.left, e.right = t.right, e.top = t.top } if (this.lastVisiblePage) { const t = this.boundingRatioForPage(this.lastVisiblePage); e.bottom = t.bottom } return e } logPageView() { const e = this.getVisibleBBox(); for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && (e[i] = this._floor2(e[i])); const t = [[e.left, e.top], [e.right, e.bottom]]; return this.fireEvent("pageView", t), e } _updateExpectedFirstPage(e) { this._expectedFirstPageNum = e, this.fireEvent("expectedFirstPageChanged", this._expectedFirstPageNum) } _loadAdjacentFonts() { if (this.firstVisiblePage && this.lastVisiblePage) { const e = this.firstVisiblePage.pageNum - this.adjacentFontLoadPages, t = this.lastVisiblePage.pageNum + this.adjacentFontLoadPages; for (let i = e; i <= t; i++) { const e = this.pages[i]; e && e.loadFonts() } } } _loadAdjacentPages() { if (this.firstVisiblePage && this.lastVisiblePage) { const e = this.firstVisiblePage.pageNum - 3, t = this.lastVisiblePage.pageNum + 3; for (let i = e; i <= t; i++) { const e = this.pages[i]; e && !e.loadHasStarted && (e.load(), this.mobile && e.setWidth(this._pageWidths)) } this.mobile && this._removeUnusedPages() } } _removeUnusedPages() { const e = this.firstVisiblePage.pageNum - 3, t = this.lastVisiblePage.pageNum + 3, i = this.pages; let s = 4; for (; i[s];)(s < e || s > t) && i[s].remove(), s++ } _updatePageBoundingRects() { for (const e in this.pages) Object.prototype.hasOwnProperty.call(this.pages, e) && this.pages[e]._updateBoundingRect() } removeInsteadOfBlurring(e) { return !!(this.truncateDocument && this.firstHiddenPageNum && e.pageNum >= this.firstHiddenPageNum) || (!!P.disablePageBlur || "undefined" === typeof Scribd) } addPage(e) { if (!this.firstHiddenPageNum && e.blur && (this.firstHiddenPageNum = e.pageNum), !this.removeInsteadOfBlurring(e)) { if (void 0 === e.pageNum) throw Error("must have pageNum param"); if (e.docManager = this, e.innerPageElem) { const t = e.innerPageElem.querySelectorAll(".absimg"); for (let i = 0; i < t.length; i++)1 === e.pageNum ? this.lazyLoad(t[i]) : t[i].style.display = "block" } const t = new p(e); return this.pages[e.pageNum] = t, this._pageWidths && t.setWidth(this._pageWidths), this.currentFontGroup.isFull() && (this.currentFontGroup = this.currentFontGroup.newNextGroup()), t.setLoadFontGroup(this.currentFontGroup), t } e.containerElem.parentNode.removeChild(e.containerElem) } setIsScrolling(e) { e ? this._scrollingCount += 1 : this._scrollingCount -= 1, this._scrollingCount < 0 && (this._scrollingCount = 0), 0 === this._scrollingCount ? this.isScrolling = !1 : this.isScrolling = !0 } setViewManager(e, t) { this._currentViewManager ? (this._setViewManager(e), "function" === typeof t && t()) : this.addEvent("viewmodeInitialized", () => { this.setViewManager(e, t) }) } _setViewManager(e, t) { t || this._currentViewManager.unregister(); const i = this._currentViewManager; this._currentViewManager = this.viewManagers[e], this._currentViewManager.register(this, this.viewportManager), this.fireEvent("viewmodeChanged", this.viewMode(), i ? i.name() : null) } setInitialViewManager(e) { if (this._currentViewManager) throw Error("This should be called before any view manager exists"); this._setViewManager(e, !0), this.fireEvent("viewmodeInitialized", this.viewMode(), null) } setDefaultWidth(e) { this._currentViewManager._currentPageWidth = e, this._currentViewManager._currentZoomMultiplier = 1, this._currentViewManager._updatePageWidths() } subImageSrc(e) { if (!this._imageDomainSubstitutionList || 0 === this._imageDomainSubstitutionList.length) return; const t = this._imageDomainSubstitutionList[0]; return e.replace(this._imageDomainSubstitutionFrom, t) } allPagesAdded() { if (this._allPagesAddedCalled) throw Error("can only call allPagesAdded once"); this.viewportManager.enable(), this._updatePageBoundingRects(), this.setInitialViewManager(this.defaultViewMode), this.fireEvent("allPagesAdded") } setEmbeddedDoc(e) { this._isEmbed = "True" === e } setPageWidths(e) { this._pageWidths = e; for (const t in this.pages) Object.prototype.hasOwnProperty.call(this.pages, t) && this.pages[t].setWidth(this._pageWidths); this._updatePageBoundingRects() } addFont(e, t, i, s, n, a) { this._fontLoader.addFont(e, t, i, s, n, a) } initStyles() { this._fontLoader.initStyles() } gotoPage(e, t) { const i = !(e % 1 === 0); let s = null; if (i && (s = +(e % 1).toFixed(2), e = Math.floor(e)), e < this.minimumPageNumber() || e > this.maximumPageNumber()) return; t || (t = {}), i && void 0 === t.frac && (t.frac = s); const n = t.direction || 0; let a = this.pages[e]; void 0 === a && this._isPaidDocument && (e = this.getClosestPageNumber(e, n), a = this.pages[e]), this.mobile && this.pages[e] && this.pages[e].setWidth(this._pageWidths), this._updateExpectedFirstPage(e), this._currentViewManager.gotoPage(this._expectedFirstPageNum, t) } gotoPreviousPage() { const e = this._currentViewManager._pagingStep(); this._currentViewManager.isTopPageInView() ? this.gotoPage(this._expectedFirstPageNum - e, { direction: -1 }) : this.gotoPage(this._expectedFirstPageNum, { direction: -1 }) } gotoNextPage() { const e = this._currentViewManager._pagingStep(); this.gotoPage(this._expectedFirstPageNum + e, { direction: 1 }) } enterFullscreen() { this._currentViewManager.enterFullscreen() } exitFullscreen() { this._currentViewManager.exitFullscreen() } isFullscreen() { return this._currentViewManager.isFullscreen } _fireEnteredFullscreen() { this.fireEvent("enteredFullscreen") } _fireExitedFullscreen() { this.fireEvent("exitedFullscreen") } viewMode() { return this._currentViewManager ? this._currentViewManager.name() : null } zoom(e) { this._currentViewManager.zoom(e) } resetZoom() { this._currentViewManager.resetZoom() } setImageDomainSubstitution(e, t) { this._imageDomainSubstitutionFrom = e, this._imageDomainSubstitutionList = t } disableViewManagerResizeWidth() { o.prototype._setBodyWidth = function () { } } disable() { this.disabled || (this.disabled = !0, this.viewportManager.disable()) } disableCopyPasteOnPage(e) { f.forEach(function (t) { e.addEventListener(t, _) }), e.setAttribute("unselectable", "on"), e.querySelectorAll("*").forEach(function (e) { e.setAttribute("unselectable", "on") }) } enableCopyPasteOnPage(e) { f.forEach(function (t) { e.removeEventListener(t, _) }), e.removeAttribute("unselectable"), e.querySelectorAll("*").forEach(function (e) { e.removeAttribute("unselectable") }) } setJQuery() { console.info("DocumentManager.setJQuery is deprecated. jQuery is no longer a dependency.") } } return i(P, "EVENT_NAMES", ["expectedFirstPageChanged", "mostVisiblePageChanged", "viewmodeChanged", "enteredFullscreen", "exitedFullscreen", "hideExtras", "showExtras", "zoomed", "pageHide", "pageLoaded", "allPagesAdded", "pageView", "visiblePagesChanged", "viewmodeInitialized"]), P }();
